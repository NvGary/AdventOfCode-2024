import { loadFromFile, Maze } from './maze';
import { onlyUniqueCoords } from '../array2d';

describe('maze utils', () => {
    describe('function loadFromFile', () => {
        it('loads maze01 correctly', () => {
            const maze = loadFromFile('./lib/16-20/test/maze01.txt');

            expect(maze.grid).toEqual([
                ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
                ['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', 'E', '#'],
                ['#', '.', '#', '.', '#', '#', '#', '.', '#', '.', '#', '#', '#', '.', '#'],
                ['#', '.', '.', '.', '.', '.', '#', '.', '#', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '.', '#'],
                ['#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.', '#'],
                ['#', '#', '#', '.', '#', '.', '#', '#', '#', '#', '#', '.', '#', '.', '#'],
                ['#', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '#', '#', '.', '#', '.', '#', '.', '#'],
                ['#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '#', '.', '#', '.', '#'],
                ['#', '.', '#', '#', '#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#'],
                ['#', 'S', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '#'],
                ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
            ]);
        });

        it('loads maze02 correctly', () => {
            const maze = loadFromFile('./lib/16-20/test/maze02.txt');

            expect(maze.grid).toEqual([
                ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
                ['#', '.', '.', '.', '#', '.', '.', '.', '#', '.', '.', '.', '#', '.', '.', 'E', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '.', '.', '.', '#', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '.', '#', '#', '#', '.', '#', '.', '#', '.', '#'],
                ['#', '.', '.', '.', '#', '.', '#', '.', '#', '.', '.', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '.', '#', '.', '#', '#', '#', '#', '#', '.', '#'],
                ['#', '.', '#', '.', '.', '.', '#', '.', '#', '.', '#', '.', '.', '.', '.', '.', '#'],
                ['#', '.', '#', '.', '#', '#', '#', '#', '#', '.', '#', '.', '#', '#', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '#'],
                ['#', '.', '#', '.', '#', '#', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#'],
                ['#', '.', '#', '.', '#', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '#', '#', '#', '#', '.', '#', '#', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.', '#'],
                ['#', '.', '#', '.', '#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
                ['#', 'S', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
                ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
            ]);
        });
    });

    describe('function solve', () => {
        it('solves maze01', () => {
            const maze = new Maze(loadFromFile('./lib/16-20/test/maze01.txt'));
            const sols = maze.solve();

            const cost = Math.min(...sols.map(({ cost: { corners, steps } }) => corners * 1000 + steps));
            expect(cost).toEqual(7036);

            const paths = sols.flatMap(({ route, mergedRoutes }) => route.concat(mergedRoutes.flatMap(r => r)));
            expect(paths.filter(onlyUniqueCoords)).toHaveLength(45);
        });

        it('solves maze02', () => {
            const maze = new Maze(loadFromFile('./lib/16-20/test/maze02.txt'));
            const sols = maze.solve();

            const cost = Math.min(...sols.map(({ cost: { corners, steps } }) => corners * 1000 + steps));
            expect(cost).toEqual(11048);

            const paths = sols.flatMap(({ route, mergedRoutes }) => route.concat(mergedRoutes.flatMap(r => r)));
            expect(paths.filter(onlyUniqueCoords)).toHaveLength(64);
        });
    });
});
